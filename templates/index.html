<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flask Supabase Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* --- Base Styles & Fonts --- */
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --light-bg: #f8f9fa;
            --white: #fff;
            --border-color: #dee2e6;
            --message-bg: #e9ecef;
            --message-user-bg: #d1e7fd; /* Background for own messages */
            --shadow-sm: 0 .125rem .25rem rgba(0,0,0,.075);
            --shadow-lg: 0 1rem 3rem rgba(0,0,0,.175);
            --border-radius: 0.375rem;
            --danger-color: #dc3545;
        }

        *, *::before, *::after { box-sizing: border-box; }

        body {
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
            margin: 0;
            background-color: var(--light-bg);
            color: #212529;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }

        /* --- Chat Container --- */
        #chat-container {
            background-color: var(--white);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 700px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            height: 85vh;
            max-height: 800px;
        }

        /* --- Header & Context --- */
         .chat-header {
             padding: 0.75rem 1.5rem;
             background-color: #f0f2f5; /* Slightly different header bg */
             border-bottom: 1px solid var(--border-color);
         }
         .chat-header h1 {
            text-align: center;
            color: var(--primary-color);
            margin: 0 0 0.5rem 0;
            font-size: 1.5rem;
            background: none; /* Remove individual bg from h1 */
            border: none;
         }
         #chat-context {
             font-size: 0.9rem;
             color: var(--secondary-color);
             text-align: center;
             min-height: 1.2em; /* Prevent layout shift */
         }
         #chat-context strong { color: var(--primary-color); }
         #chat-context button { /* Back to public button */
             margin-left: 10px;
             font-size: 0.8rem;
             padding: 2px 6px;
             cursor: pointer;
             background-color: var(--secondary-color);
             color: white;
             border: none;
             border-radius: 3px;
             vertical-align: middle;
         }
         #chat-context button:hover { background-color: #5a6268; }


        /* --- User Setup Area (Combined Prompt & Private Chat Input) --- */
        #user-setup-area {
             padding: 1rem 1.5rem;
             border-bottom: 1px solid var(--border-color);
             background-color: #f8f9fa;
        }
         #username-prompt, #private-chat-prompt {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem; /* Space between prompts */
        }
         #private-chat-prompt {
            margin-bottom: 0; /* No margin below the last item */
         }
         #user-setup-area label {
            font-weight: 500;
            min-width: 80px; /* Align inputs */
            text-align: right;
             margin-right: 0.5rem;
         }
         #user-setup-area input[type="text"] {
            flex-grow: 1;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 0.9rem;
        }
         #user-setup-area input[type="text"]:focus {
             outline: none;
             border-color: #86b7fe;
             box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, .25);
         }
        #user-setup-area button {
            padding: 0.5rem 1rem;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s ease;
            white-space: nowrap;
        }
        #user-setup-area button:hover { background-color: #0b5ed7; }
         #start-private-chat-btn { background-color: var(--secondary-color); }
         #start-private-chat-btn:hover { background-color: #5a6268; }

         /* Hide private chat until username is set */
        #private-chat-prompt { display: none; }


        /* --- Chatbox Area --- */
        #chatbox {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
            background-color: var(--white);
            display: flex;
            flex-direction: column-reverse;
        }

        /* --- Message Bubbles --- */
        .message {
            margin-bottom: 0.75rem;
            padding: 0.6rem 1rem;
            border-radius: 1rem;
            background-color: var(--message-bg);
            max-width: 75%;
            word-wrap: break-word;
            align-self: flex-start; /* Default left alignment */
            opacity: 0;
            transform: translateY(10px);
            animation: fadeIn 0.3s ease forwards;
             position: relative; /* For timestamp absolute positioning */
        }

        /* Style for messages sent BY the current user */
        .message.own-message {
             background-color: var(--message-user-bg);
             align-self: flex-end; /* Align own messages to the right */
        }

        .message strong { /* Username */
            display: block;
            color: var(--primary-color);
            font-weight: 600;
            margin-bottom: 0.2rem;
             font-size: 0.9em;
        }
        .message.own-message strong {
             /* Optionally hide own username or style differently */
             /* display: none; */
             color: #0a58ca; /* Slightly darker blue */
         }

         /* Private message indicator */
         .message .private-indicator {
            font-size: 0.7em;
            font-style: italic;
            color: var(--danger-color);
            margin-left: 5px;
            font-weight: normal;
        }

        .message span { /* Timestamp */
            display: block;
            font-size: 0.75em;
            color: var(--secondary-color);
            margin-top: 0.3rem;
            text-align: right;
        }

        /* --- Message Input Form --- */
        #message-form {
            display: flex;
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            background-color: #f8f9fa;
            gap: 0.5rem;
        }
        #message-form.disabled {
            opacity: 0.6;
            pointer-events: none;
        }
        #message-input {
            flex-grow: 1;
            padding: 0.6rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 1rem;
             resize: none;
        }
        #message-input:focus {
             outline: none;
             border-color: #86b7fe;
             box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, .25);
         }
        #message-form button {
            padding: 0.6rem 1.2rem;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
             font-weight: 500;
            transition: background-color 0.2s ease;
             white-space: nowrap;
        }
        #message-form button:hover { background-color: #0b5ed7; }

        /* Scrollbar & Animation */
        #chatbox::-webkit-scrollbar { width: 8px; }
        #chatbox::-webkit-scrollbar-track { background: transparent; margin: 5px 0; }
        #chatbox::-webkit-scrollbar-thumb { background-color: #ced4da; border-radius: 10px; border: 2px solid var(--white); }
        #chatbox::-webkit-scrollbar-thumb:hover { background-color: #adb5bd; }
        @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }
        #chatbox p { text-align: center; color: var(--secondary-color); font-style: italic; width: 100%; margin-top: 2rem; }
    </style>
</head>
<body>
    <div id="chat-container">

         <div class="chat-header">
             <h1>⚡️ Supa Real-Time Chat ⚡️</h1>
             <div id="chat-context">Public Chat</div> <!-- Dynamic context display -->
         </div>

        <div id="user-setup-area">
            <!-- Username Prompt -->
            <div id="username-prompt">
                <label for="username-input">Username:</label>
                <input type="text" id="username-input" placeholder="Choose a name...">
                <button id="set-username-btn">Set</button>
            </div>
            <!-- Private Chat Prompt (hidden initially) -->
            <div id="private-chat-prompt">
                 <label for="recipient-input">Chat with:</label>
                 <input type="text" id="recipient-input" placeholder="Enter recipient username...">
                 <button id="start-private-chat-btn">Start Private</button>
             </div>
        </div>


        <!-- Chat messages area -->
        <div id="chatbox">
             <p>Enter username to start chatting!</p>
        </div>

        <!-- Message input form (disabled initially) -->
        <form id="message-form" class="disabled">
            <input type="text" id="message-input" placeholder="Enter message..." autocomplete="off" required disabled>
            <button type="submit" disabled>Send</button>
        </form>
    </div> <!-- End of chat-container -->

    <script>
        // --- Constants & Supabase Client ---
        const SUPABASE_URL = '{{ supabase_url }}';
        const SUPABASE_KEY = '{{ supabase_key }}';
        const PUBLIC_CHAT_CONTEXT = null; // Use null to represent public chat in DB

        if (!SUPABASE_URL || !SUPABASE_KEY) {
            alert('Error: Supabase credentials not found!');
            throw new Error("Supabase credentials missing.");
        }

        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);

        // --- DOM Elements ---
        const chatContainer = document.getElementById('chat-container');
        const chatbox = document.getElementById('chatbox');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message-input');
        const messageSendButton = messageForm.querySelector('button');
        const usernamePrompt = document.getElementById('username-prompt');
        const usernameInput = document.getElementById('username-input');
        const setUsernameBtn = document.getElementById('set-username-btn');
        const privateChatPrompt = document.getElementById('private-chat-prompt');
        const recipientInput = document.getElementById('recipient-input');
        const startPrivateChatBtn = document.getElementById('start-private-chat-btn');
        const chatContextDisplay = document.getElementById('chat-context');

        // --- State Variables ---
        let currentUsername = localStorage.getItem('chat_username') || '';
        let currentChatContext = PUBLIC_CHAT_CONTEXT; // null for public, username string for private
        let realtimeChannel = null;
        let messagesLoaded = false; // Flag to prevent duplicate message display on initial load + realtime catch-up

        // --- UI Update Functions ---
        function enableChatInput() {
            messageInput.disabled = false;
            messageSendButton.disabled = false;
            messageForm.classList.remove('disabled');
             if(document.activeElement === usernameInput || document.activeElement === recipientInput) {
                messageInput.focus(); // Focus input only if user setup was just completed
             }
        }

        function disableChatInput(placeholder = 'Enter message...') {
            messageInput.disabled = true;
            messageSendButton.disabled = true;
            messageForm.classList.add('disabled');
             messageInput.placeholder = placeholder;
        }

        function updateChatContextUI() {
            let contextHTML = '';
            if (currentChatContext === PUBLIC_CHAT_CONTEXT) {
                contextHTML = 'Public Chat';
                recipientInput.value = ''; // Clear recipient input when public
            } else {
                contextHTML = `Chatting with <strong>${currentChatContext}</strong> <button id="back-to-public-btn">Back to Public</button>`;
            }
            chatContextDisplay.innerHTML = contextHTML;

            // Add event listener for the dynamically added button
            const backBtn = document.getElementById('back-to-public-btn');
            if (backBtn) {
                backBtn.addEventListener('click', switchToPublicChat);
            }
        }


        // --- Core Logic Functions ---

        function displayMessage(message, isInitialLoad = false) {
             // Simple check to prevent duplicate display if realtime catches up fast during initial load
             if (!isInitialLoad && !messagesLoaded) return;

            const msgElement = document.createElement('div');
            msgElement.classList.add('message');

            const isOwnMessage = message.username === currentUsername;
            const isPrivate = message.recipient_username !== null; // Check if it's a private message

            if (isOwnMessage) {
                msgElement.classList.add('own-message');
            }

            const date = new Date(message.created_at);
            const timeString = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });

            let privateIndicatorHTML = '';
            if (isPrivate) {
                 // Indicate who the private message is *to* or *from* if not the current chat partner
                 if (isOwnMessage && message.recipient_username !== currentChatContext) {
                    privateIndicatorHTML = `<span class="private-indicator">(to ${message.recipient_username})</span>`;
                 } else if (!isOwnMessage && message.username !== currentChatContext) {
                    // This case should technically be filtered out by fetch/realtime logic
                    // but kept for robustness / potential cross-private-chat scenarios later
                    // privateIndicatorHTML = `<span class="private-indicator">(from ${message.username})</span>`;
                 } else if (currentChatContext === PUBLIC_CHAT_CONTEXT){
                      // If viewing public chat, but seeing own private messages
                      if(isOwnMessage) privateIndicatorHTML = `<span class="private-indicator">(Private to ${message.recipient_username})</span>`;
                      // If viewing public chat, received a private message (shouldn't happen with proper filtering/RLS)
                      // else privateIndicatorHTML = `<span class="private-indicator">(Private from ${message.username})</span>`;
                 }
             }


            msgElement.innerHTML = `
                <strong>${message.username || 'Anon'} ${privateIndicatorHTML}</strong>
                ${message.content}
                <span>${timeString}</span>
            `;
            chatbox.prepend(msgElement);

            // Clear initial prompt if it exists
             clearInitialPrompt();
        }

        function clearInitialPrompt(){
             const initialPrompt = chatbox.querySelector('p');
             if (initialPrompt && (initialPrompt.textContent.includes('start chatting') || initialPrompt.textContent.includes('No messages') || initialPrompt.textContent.includes('Loading'))) {
                 initialPrompt.remove();
             }
         }

        async function fetchMessages() {
            messagesLoaded = false; // Reset flag
            chatbox.innerHTML = '<p>Loading messages...</p>'; // Indicate loading

            let query = supabaseClient
                .from('messages')
                .select('*')
                .order('created_at', { ascending: false })
                .limit(100); // Load more messages potentially

            if (currentChatContext === PUBLIC_CHAT_CONTEXT) {
                // Fetch only public messages
                query = query.is('recipient_username', null);
            } else {
                // Fetch private messages between currentUsername and currentChatContext
                query = query.or(`and(username.eq.${currentUsername},recipient_username.eq.${currentChatContext}),and(username.eq.${currentChatContext},recipient_username.eq.${currentUsername})`);
            }

            const { data: messages, error } = await query;

             chatbox.innerHTML = ''; // Clear loading message

            if (error) {
                console.error('Error fetching messages:', error);
                chatbox.innerHTML = `<p style="color: red;">Error loading messages: ${error.message}</p>`;
                 disableChatInput("Cannot load messages");
            } else if (messages && messages.length > 0) {
                 messages.forEach(msg => displayMessage(msg, true)); // Pass true for initial load
             } else {
                 chatbox.innerHTML = '<p>No messages in this chat yet.</p>';
            }
             messagesLoaded = true; // Set flag after initial load
        }

        async function sendMessage(event) {
            event.preventDefault();
            const messageText = messageInput.value.trim();

            if (!messageText || !currentUsername) return;

            const recipient = currentChatContext; // This is null for public chat
            const messageData = {
                 username: currentUsername,
                 content: messageText,
                 recipient_username: recipient // Will be null if currentChatContext is null
            };

            const tempInputValue = messageInput.value;
            messageInput.value = ''; // Clear optimistically

             try {
                const { error } = await supabaseClient.from('messages').insert([messageData]);
                if (error) {
                     console.error('Error sending message:', error);
                     alert(`Failed to send message: ${error.message}`);
                     messageInput.value = tempInputValue; // Restore on error
                 }
                 // Success: Realtime listener will handle display
             } catch (err) {
                 console.error('Network/DB error sending message:', err);
                 alert('An error occurred sending the message.');
                 messageInput.value = tempInputValue;
             }
        }

         function setupRealtime() {
            // Ensure only one channel exists
            if (realtimeChannel) {
                supabaseClient.removeChannel(realtimeChannel)
                   .catch(err => console.warn("Error removing previous channel (might be normal on fast switch):", err));
                realtimeChannel = null; // Reset variable
                 console.log('Previous realtime channel removed.');
            }

             console.log(`Setting up realtime listener for: User=${currentUsername}, Context=${currentChatContext || 'Public'}`);

            // Unique channel name per user might be better in complex scenarios, but 'public:messages' works if filtered client-side correctly.
             realtimeChannel = supabaseClient
                 .channel(`realtime_chat_${currentUsername}`) // Channel name more specific
                 .on(
                     'postgres_changes',
                      // Listen for *all* inserts initially. We filter client-side below.
                      // Server-side filtering here is more complex with OR conditions needed for private chats.
                     { event: 'INSERT', schema: 'public', table: 'messages'},
                     (payload) => {
                         if (!messagesLoaded) {
                             console.log("Realtime message received before initial load complete, skipping display:", payload.new.id);
                             return; // Avoid race conditions / duplicates
                         }

                         const newMessage = payload.new;
                         console.log('Realtime message received:', newMessage);

                         const isPublic = newMessage.recipient_username === null;
                         const sentByMe = newMessage.username === currentUsername;
                         const sentToMe = newMessage.recipient_username === currentUsername;
                         const relevantToCurrentPrivateChat =
                                currentChatContext !== PUBLIC_CHAT_CONTEXT &&
                                ( (sentByMe && newMessage.recipient_username === currentChatContext) || // I sent it to current partner
                                  (sentToMe && newMessage.username === currentChatContext) );           // Current partner sent it to me


                         // Display Logic based on current view context:
                         if (currentChatContext === PUBLIC_CHAT_CONTEXT) {
                              // In public view, only show public messages
                              if(isPublic) {
                                 console.log("Displaying public message in public view");
                                 displayMessage(newMessage);
                              } else {
                                  console.log("Ignoring private message while in public view");
                              }
                         } else {
                             // In private view (e.g., chatting with 'Alice')
                             if (relevantToCurrentPrivateChat) {
                                 console.log("Displaying message relevant to private chat view");
                                 displayMessage(newMessage);
                             } else {
                                  console.log("Ignoring message not relevant to current private chat view");
                             }
                         }
                     }
                 )
                 .subscribe((status, err) => {
                     console.log(`Realtime channel subscription status: ${status}`);
                     if (status === 'SUBSCRIBED') {
                         console.log(`Connected to realtime channel for context: ${currentChatContext || 'Public'}`);
                         enableChatInput(); // Re-enable input on successful connection/reconnection
                     } else if (status === 'CHANNEL_ERROR') {
                         console.error('Realtime channel error:', err);
                         alert(`Realtime connection error: ${err?.message || 'Unknown'}. Refresh?`);
                          disableChatInput("Realtime connection failed");
                     } else if (status === 'TIMED_OUT') {
                         console.warn('Realtime connection timed out.');
                          disableChatInput("Realtime connection timed out");
                         // Optional: Implement retry logic here
                     } else if (status === 'CLOSED'){
                         console.log('Realtime channel closed.');
                          disableChatInput("Realtime connection closed");
                          // Maybe attempt reconnect or prompt user
                     }
                 });
                 console.log("Subscribing...")
         }

        // --- Context Switching Functions ---

        function startPrivateChat() {
            const recipient = recipientInput.value.trim();
            if (!recipient) {
                alert('Please enter a username to chat with.');
                return;
            }
            if (recipient === currentUsername) {
                alert("You can't start a private chat with yourself!");
                return;
            }

            console.log(`Starting private chat with: ${recipient}`);
            currentChatContext = recipient; // Set the context
             recipientInput.value = ''; // Clear input after starting
             updateChatContextUI();       // Update the header display
             disableChatInput("Loading private chat..."); // Disable while loading
            fetchMessages();          // Fetch messages for the new private context
             setupRealtime();          // Resubscribe with potentially new filters needed (handled by client filtering)
             // Input will be re-enabled by the realtime 'SUBSCRIBED' status or fetch success
        }

        function switchToPublicChat() {
            console.log("Switching back to public chat.");
            currentChatContext = PUBLIC_CHAT_CONTEXT;
             updateChatContextUI();
             disableChatInput("Loading public chat...");
            fetchMessages();
             setupRealtime();
             // Input will be re-enabled by the realtime 'SUBSCRIBED' status or fetch success
        }


        // --- Event Listeners & Initialisation ---

         function handleSetUsername() {
             const name = usernameInput.value.trim();
             if (name) {
                 currentUsername = name;
                 localStorage.setItem('chat_username', currentUsername);
                 usernamePrompt.style.display = 'none';     // Hide username prompt
                 privateChatPrompt.style.display = 'flex'; // Show private chat input
                 recipientInput.focus();                    // Focus recipient input
                 updateChatContextUI(); // Ensure header reflects public chat initially
                 disableChatInput("Loading public chat..."); // Disable until loaded
                 fetchMessages();       // Load initial public messages
                 setupRealtime();       // Connect to realtime
             } else {
                 alert('Please enter a valid username.');
             }
         }

        setUsernameBtn.addEventListener('click', handleSetUsername);
        usernameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleSetUsername(); });

        startPrivateChatBtn.addEventListener('click', startPrivateChat);
        recipientInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') startPrivateChat(); });

        messageForm.addEventListener('submit', sendMessage);

         function initializeChat() {
             updateChatContextUI(); // Set initial "Public Chat" text
             if (currentUsername) {
                 usernameInput.value = currentUsername;
                 usernamePrompt.style.display = 'none'; // Hide username prompt
                 privateChatPrompt.style.display = 'flex';// Show private chat input
                 disableChatInput("Loading public chat..."); // Disable input initially
                 fetchMessages();
                 setupRealtime();
             } else {
                 // Show username prompt, hide private chat, disable form
                 usernamePrompt.style.display = 'flex';
                 privateChatPrompt.style.display = 'none';
                 disableChatInput("Set username to chat"); // Inform user
                 chatbox.innerHTML = '<p>Please enter a username to start chatting.</p>'; // Reset chatbox
                 usernameInput.focus();
            }
        }

        document.addEventListener('DOMContentLoaded', initializeChat);

        window.addEventListener('beforeunload', () => {
            if (realtimeChannel) {
                console.log("Unsubscribing from Supabase channel before unload...");
                supabaseClient.removeChannel(realtimeChannel)
                    .catch(err => console.warn("Error removing channel on unload:", err));
            }
        });

    </script>

</body>
</html>